<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Candy Realm V86 | BZ247 Studios</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap');
        * { user-select: none; -webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0; padding: 0; }
        
        body { 
            background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);
            background-size: 400% 400%; animation: bgShift 15s ease infinite;
            color: #fff; font-family: 'Fredoka', sans-serif; height: 100vh; display: flex; 
            flex-direction: column; align-items: center; justify-content: center; overflow: hidden; 
        }
        @keyframes bgShift { 0% {background-position: 0% 50%} 50% {background-position: 100% 50%} 100% {background-position: 0% 50%} }

        /* --- MAP SCREEN --- */
        #map-overlay { position: fixed; inset: 0; background: radial-gradient(circle at center, rgba(10, 10, 20, 0.98), #000); z-index: 2000; display: flex; flex-direction: column; align-items: center; justify-content: center; backdrop-filter: blur(25px); padding: 20px 0; }
        .map-card { background: rgba(255, 255, 255, 0.04); padding: 30px 20px; border-radius: 40px; border: 2px solid rgba(255, 255, 255, 0.1); width: 92%; max-width: 400px; max-height: 75vh; display: flex; flex-direction: column; gap: 15px; overflow-y: auto; scrollbar-width: none; }
        .map-card::-webkit-scrollbar { display: none; }
        .level-node { width: 100%; padding: 22px 30px; border-radius: 22px; border: none; font-weight: 700; font-size: 19px; color: #fff; display: flex; justify-content: space-between; align-items: center; transition: 0.3s; position: relative; flex-shrink: 0; }
        .level-node.unlocked { background: linear-gradient(90deg, #ff00cc, #3333ff, #ff00cc); background-size: 200% auto; animation: chromaMove 5s linear infinite; cursor: pointer; border: 3px solid rgba(255, 255, 255, 0.3); box-shadow: 0 8px 20px rgba(255, 0, 204, 0.3); }

        /* --- OVERLAYS --- */
        .game-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 3000; display: none; flex-direction: column; align-items: center; justify-content: center; backdrop-filter: blur(15px); }
        .status-card { background: rgba(255, 255, 255, 0.1); padding: 40px; border-radius: 50px; border: 2px solid rgba(255, 255, 255, 0.2); text-align: center; width: 85%; max-width: 350px; }
        .star-rating-3d { font-size: 20px; font-weight: 900; background: linear-gradient(180deg, #fff 0%, #ffd700 45%, #b8860b 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 2px 0 #8b4513) drop-shadow(0 4px 10px rgba(0,0,0,0.5)); }
        #victory-canvas { position: absolute; inset: 0; pointer-events: none; z-index: 3001; }

        /* --- GAME UI --- */
        #game-ui { display: none; flex-direction: column; align-items: center; width: 100%; }
        .header-glass { width: 94%; max-width: 440px; background: rgba(255, 255, 255, 0.15); backdrop-filter: blur(25px); border-radius: 30px; padding: 15px; margin-bottom: 20px; border: 3.5px solid #ff0080; }
        .stats-top { display: grid; grid-template-columns: repeat(3, 1fr) 45px 45px; gap: 8px; align-items: center; text-align: center; }
        .task-row { width: 100%; margin-top: 10px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 15px; display: flex; justify-content: center; align-items: center; gap: 10px; font-size: 16px; font-weight: 700; color: #00ff00; }

        /* --- BOARD & OBSTACLES --- */
        #board-container { position: relative; }
        #board { display: grid; grid-template-columns: repeat(7, 1fr); grid-template-rows: repeat(8, 1fr); grid-gap: 8px; width: 90vw; max-width: 360px; transition: transform 0.1s; }
        .cell { background: rgba(255, 255, 255, 0.12); border-radius: 12px; display: flex; align-items: center; justify-content: center; border: 1.5px solid rgba(255,255,255,0.15); position: relative; }
        .candy { font-size: 32px; pointer-events: none; transition: all 0.8s cubic-bezier(0.22, 1, 0.36, 1); }
        .matched { transform: scale(0); opacity: 0; }
        
        .candy.bomb { filter: drop-shadow(0 0 10px #ff0000); animation: pulse 0.8s infinite; }
        .candy.bomb::before { content: 'üí£'; position: absolute; font-size: 14px; top: -8px; right: -8px; }
        .shake { animation: boardShake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes boardShake { 10%, 90% { transform: translate3d(-2px, 0, 0); } 20%, 80% { transform: translate3d(4px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-6px, 0, 0); } 40%, 60% { transform: translate3d(6px, 0, 0); } }

        .chained::after { content: '‚õìÔ∏è'; position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-size: 28px; background: rgba(0,0,0,0.3); border-radius: 12px; }
        .frozen::after { content: '‚ùÑÔ∏è'; position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-size: 28px; background: rgba(100,200,255,0.4); border-radius: 12px; }
    </style>
</head>
<body>

    <div id="map-overlay">
        <h1 style="font-size: 30px; margin-bottom: 25px; letter-spacing: 3px;">CANDY MAP</h1>
        <div class="map-card" id="map-nodes"></div>
    </div>

    <div id="victory-screen" class="game-overlay">
        <canvas id="victory-canvas"></canvas>
        <div class="status-card">
            <h1 style="color:#ffd700; margin-bottom:15px; font-size: 32px;">GREAT JOB!</h1>
            <div class="star-rating-3d" style="font-size: 40px;">‚òÖ‚òÖ‚òÖ</div>
            <button onclick="backToMap()" style="padding: 15px 40px; border-radius: 30px; border: none; background: linear-gradient(90deg, #ff00cc, #3333ff); color: #fff; font-weight: 700; cursor: pointer; margin-top: 25px;">CONTINUE ‚ñ∂</button>
        </div>
    </div>

    <div id="game-ui">
        <div class="header-glass">
            <div class="stats-top">
                <div class="stat-item"><small style="color:#ffd700; font-size:9px;">MOVES</small><b id="mDisplay" style="display:block; font-size:20px;">30</b></div>
                <div class="stat-item"><small style="color:#ffd700; font-size:9px;">LEVEL</small><b id="lDisplay" style="display:block; font-size:20px;">1</b></div>
                <div class="stat-item"><small style="color:#ffd700; font-size:9px;">SCORE</small><b id="sDisplay" style="display:block; font-size:20px;">0</b></div>
                <div style="cursor:pointer; font-size:18px;" onclick="toggleAudio()" id="audioToggle">üîä</div>
                <div style="cursor:pointer; font-size:18px;" onclick="backToMap()">‚è∏</div>
            </div>
            <div class="task-row"><span id="taskDisplay">üçé 0/20</span></div>
        </div>
        <div id="board-container"><div id="board"></div></div>
    </div>

<script>
    let audioCtx = null, isMuted = false;
    function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
    function playPop(f = 400) { if (isMuted || !audioCtx) return; let o = audioCtx.createOscillator(), g = audioCtx.createGain(); o.frequency.setValueAtTime(f, audioCtx.currentTime); g.gain.setValueAtTime(0.1, audioCtx.currentTime); o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + 0.1); }
    function toggleAudio() { isMuted = !isMuted; document.getElementById('audioToggle').innerText = isMuted ? 'üîá' : 'üîä'; }

    const canvas = document.getElementById('victory-canvas'), ctx = canvas.getContext('2d');
    let particles = [];
    function spawnParticles() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; for(let i=0; i<80; i++) { particles.push({ x: canvas.width/2, y: canvas.height/2, vx: (Math.random()-0.5)*15, vy: (Math.random()-0.5)*15, color: `hsl(${Math.random()*360}, 100%, 50%)`, size: Math.random()*4+2, life: 1 }); } }
    function animateParticles() { if (document.getElementById('victory-screen').style.display !== 'flex') return; ctx.clearRect(0,0,canvas.width,canvas.height); particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.vy += 0.2; p.life -= 0.01; ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill(); if(p.life <= 0) particles.splice(i, 1); }); if(particles.length < 40) spawnParticles(); requestAnimationFrame(animateParticles); }

    let taskEmoji = '', taskCount = 0, taskTarget = 0, currentLevel = 1, unlockedLevel = 1;
    let score = 0, moves = 30, targetScore = 2000, isProcessing = false, grid = [], isInitialCheck = false;
    let touchStartX, touchStartY, activeCell = null;
    const width = 7, rows = 8, emojisMaster = ['üçì', 'üçä', 'üçá', 'üçè', 'üçã', 'üçí'];

    function renderMap() {
        const container = document.getElementById('map-nodes'); container.innerHTML = '';
        for(let i=1; i<=50; i++) {
            const btn = document.createElement('button');
            const isUnlocked = i <= unlockedLevel;
            btn.className = 'level-node' + (isUnlocked ? ' unlocked' : ' locked');
            btn.innerHTML = `<div>LEVEL ${i}</div> <div class="star-rating-3d">${isUnlocked ? "‚òÖ‚òÖ‚òÖ" : "‚òÜ‚òÜ‚òÜ"}</div>`;
            if(isUnlocked) btn.onclick = () => { initAudio(); startLevel(i); };
            container.appendChild(btn);
        }
    }

    function startLevel(lvl) {
        currentLevel = lvl; isInitialCheck = true;
        document.getElementById('map-overlay').style.display = 'none';
        document.getElementById('game-ui').style.display = 'flex';
        taskEmoji = emojisMaster[(lvl - 1) % 4];
        taskTarget = 20 + (lvl * 5); targetScore = 1500 + (lvl * 800);
        moves = Math.max(10, 40 - Math.floor(lvl * 0.5));
        score = 0; taskCount = 0;
        document.getElementById('lDisplay').innerText = lvl;
        updateHUD(); initGame();
    }

    /* --- FIXED BACK TO MAP LOGIC --- */
    function backToMap() { 
        document.getElementById('map-overlay').style.display = 'flex'; 
        document.getElementById('game-ui').style.display = 'none'; 
        document.getElementById('victory-screen').style.display = 'none'; // CRITICAL FIX
        renderMap(); 
    }

    function initGame() {
        grid = []; document.getElementById('board').innerHTML = '';
        const count = Math.min(6, 4 + Math.floor(currentLevel / 15));
        for (let i = 0; i < width * rows; i++) {
            const cell = document.createElement('div'); cell.className = 'cell'; cell.setAttribute('data-id', i);
            cell.addEventListener('touchstart', (e) => { touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY; activeCell = cell; });
            cell.addEventListener('touchend', (e) => { if (activeCell) handleSwipe(e.changedTouches[0].clientX, e.changedTouches[0].clientY); });
            const candy = createCandy(count);
            if (currentLevel >= 5 && Math.random() < 0.1) cell.classList.add('frozen');
            if (currentLevel >= 12 && Math.random() < 0.1) cell.classList.add('chained');
            cell.appendChild(candy); document.getElementById('board').appendChild(cell); grid.push(cell);
        }
        setTimeout(checkMatches, 800);
    }

    function createCandy(count) {
        const c = document.createElement('div'); c.className = 'candy';
        const clr = Math.floor(Math.random() * count); c.setAttribute('data-color', clr);
        c.innerHTML = emojisMaster[clr]; return c;
    }

    function handleSwipe(endX, endY) {
        if (isProcessing) return;
        let dX = endX - touchStartX, dY = endY - touchStartY;
        let id = parseInt(activeCell.getAttribute('data-id')), tId = -1;
        if (Math.abs(dX) > Math.abs(dY)) { if (Math.abs(dX) > 30) tId = dX > 0 ? id + 1 : id - 1; }
        else { if (Math.abs(dY) > 30) tId = dY > 0 ? id + width : id - width; }
        if (tId >= 0 && tId < grid.length) {
            if (Math.abs(id - tId) === 1 && Math.floor(id / width) !== Math.floor(tId / width)) tId = -1;
            if (tId !== -1 && !activeCell.classList.contains('chained') && !grid[tId].classList.contains('chained') && !activeCell.classList.contains('frozen') && !grid[tId].classList.contains('frozen')) {
                performSwap(activeCell, grid[tId]);
            }
        }
        activeCell = null;
    }

    function performSwap(c1, c2) {
        isProcessing = true;
        const f1 = c1.querySelector('.candy'), f2 = c2.querySelector('.candy');
        c1.appendChild(f2); c2.appendChild(f1);
        playPop(300); moves--; updateHUD();
        setTimeout(checkMatches, 800);
    }

    function checkMatches() {
        let matched = new Set();
        let bombsToCreate = [];
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < width - 2; c++) {
                let i = r * width + c, c1 = grid[i].querySelector('.candy')?.getAttribute('data-color');
                if (c1 && c1 === grid[i+1].querySelector('.candy')?.getAttribute('data-color') && c1 === grid[i+2].querySelector('.candy')?.getAttribute('data-color')) {
                    matched.add(i); matched.add(i+1); matched.add(i+2);
                    if (c < width-3 && grid[i+3].querySelector('.candy')?.getAttribute('data-color') === c1) { matched.add(i+3); bombsToCreate.push(i+3); }
                }
            }
        }
        for (let c = 0; c < width; c++) {
            for (let r = 0; r < rows - 2; r++) {
                let i = r * width + c, c1 = grid[i].querySelector('.candy')?.getAttribute('data-color');
                if (c1 && c1 === grid[i+width].querySelector('.candy')?.getAttribute('data-color') && c1 === grid[i+width*2].querySelector('.candy')?.getAttribute('data-color')) {
                    matched.add(i); matched.add(i+width); matched.add(i+width*2);
                    if (r < rows-3 && grid[i+width*3].querySelector('.candy')?.getAttribute('data-color') === c1) { matched.add(i+width*3); bombsToCreate.push(i+width*3); }
                }
            }
        }
        if (matched.size > 0) {
            playPop(500);
            matched.forEach(i => {
                const cell = grid[i], candy = cell.querySelector('.candy');
                if (candy && candy.classList.contains('bomb')) {
                    document.getElementById('board').classList.add('shake');
                    setTimeout(() => document.getElementById('board').classList.remove('shake'), 400);
                    explodeArea(i);
                }
                if (cell.classList.contains('frozen')) cell.classList.remove('frozen');
                if (cell.classList.contains('chained')) cell.classList.remove('chained');
                else {
                    if (!isInitialCheck && emojisMaster[candy?.getAttribute('data-color')] === taskEmoji) taskCount++;
                    candy?.classList.add('matched');
                }
            });
            bombsToCreate.forEach(i => { setTimeout(() => { const c = grid[i].querySelector('.candy'); if(c) { c.classList.add('bomb'); c.classList.remove('matched'); } }, 400); });
            if (!isInitialCheck) score += matched.size * 50; updateHUD();
            if(!isInitialCheck && taskCount >= taskTarget && score >= targetScore) { checkWin(); return; }
            setTimeout(() => { matched.forEach(i => { const c = grid[i].querySelector('.candy.matched'); if(c) grid[i].removeChild(c); }); applyGravity(); }, 800);
        } else { isInitialCheck = false; isProcessing = false; checkWin(); }
    }

    function explodeArea(index) {
        playPop(200);
        const r = Math.floor(index / width), c = index % width;
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                let nr = r + i, nc = c + j;
                if (nr >= 0 && nr < rows && nc >= 0 && nc < width) {
                    let target = nr * width + nc;
                    const cnd = grid[target].querySelector('.candy');
                    if(cnd) cnd.classList.add('matched');
                    grid[target].classList.remove('frozen', 'chained');
                }
            }
        }
    }

    function checkWin() {
        if(taskCount >= taskTarget && score >= targetScore) { 
            // FIXED UNLOCK LOGIC
            if(currentLevel >= unlockedLevel) unlockedLevel = currentLevel + 1;
            document.getElementById('victory-screen').style.display = 'flex'; 
            particles = []; spawnParticles(); animateParticles();
        } else if (moves <= 0) { backToMap(); }
    }

    function applyGravity() {
        const count = Math.min(6, 4 + Math.floor(currentLevel / 15));
        for (let c = 0; c < width; c++) {
            let empty = 0;
            for (let r = rows - 1; r >= 0; r--) {
                let i = r * width + c;
                if (!grid[i].querySelector('.candy') || grid[i].querySelector('.candy.matched')) {
                    const bad = grid[i].querySelector('.candy'); if(bad) grid[i].removeChild(bad);
                    empty++;
                } else if (empty > 0) { grid[i + (empty * width)].appendChild(grid[i].querySelector('.candy')); }
            }
            for (let i = 0; i < empty; i++) { grid[i * width + c].appendChild(createCandy(count)); }
        }
        setTimeout(checkMatches, 1000);
    }

    function updateHUD() { 
        document.getElementById('sDisplay').innerText = score; document.getElementById('mDisplay').innerText = moves; 
        document.getElementById('taskDisplay').innerText = `GOAL: ${taskEmoji} ${Math.min(taskCount, taskTarget)}/${taskTarget}`;
    }
    renderMap();
</script>
</body>
</html>
